(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Baskerville"] = factory();
	else
		root["Baskerville"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default, process, registerProcessor, tokenize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"process\", function() { return processTokens; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerProcessor\", function() { return registerProcessor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenize\", function() { return tokenizeUserAgent; });\n/* eslint-disable no-param-reassign */\nconst IN_PARENS_EXTRACTOR = new RegExp(\"\\\\(\" // begin parens\n+ \"(?!like)\" // ignore if it starts with \"like\", e.g. KHTML/4.4.3 (like Gecko)\n+ \"(.*?)\" // extract this part\n+ \"\\\\)\", // end parens\n\"g\");\nconst IN_PARENS_SPLITTER = /;\\s*/g;\nconst IN_PARENS_MATCHER = new RegExp(\"(.+?)\" // lazily match anything, and save it -- this is the \"name\" field\n+ \"[/. ]?\" + \"(\" // save the version\n// versions can occasionally start with some text,\n// e.g. ADR-1111101157, as long as that text is separated from the rest by a hyphen\n+ \"(?:\\\\w+-)?\" + \"\\\\d+\" // required to have at least 1 number\n// and a number of alphanumeric fields separated by a dot, underscore or hyphen\n+ \"(?:[._-]?\\\\w)*\" + \")?\" // yeah, version isn't actually required.\n// some tokens have a \"like\" comment,\n// e.g. KHTML, like Gecko or CPU iPhone OS 2_0_1 like Mac OS X\n+ \"(?:,? like (.*?)\\\\s*)?$\");\nconst OUT_PARENS_MATCHER = new RegExp(\"([\\\\w-]+)\" // here's our name field. unlike in parens, spaces are NOT allowed\n+ \"(?:\" + \"/\" // name is separated from the version by a /\n+ \"(\\\\S+)\" // our version field\n+ \")?\" + \"(?:\\\\s+\\\\(like\\\\s+(.*?)\\\\))?\", // and the optional \"like\" comment\n\"g\"); // eslint-disable-next-line max-len\n\nconst BROWSERS = /^applewebkit|camino|chrome|chromeframe|edge|firefox|fluid|gecko|(?:ms)?ie(?: mobile)?|khtml|konqueror|mozilla|opera(?: mobi| mini)?|presto|safari|samsung internet|trident|(?:android|baidu|blackberry|qq|uc) browser$/i; // eslint-disable-next-line max-len\n\nconst OPERATING_SYSTEMS = /^android|beos|blackberry|cri?os|kubuntu|(?:freebsd|linux|openbsd)(?: \\w*)?|macintosh|mac_powerpc|macos|(?:intel|ppc)? ?mac os x|sunos|symbos|ubuntu|win(?:dows )?(?:95|98|nt|ce)?$/i;\nconst processors = [\n/**\n * Identifies the security token.\n *\n * @private\n * @method  processSecurityToken\n *\n * @param   {Object} token       A baskerville token\n * @param   {String} token.name  One of the letters N, U, or I\n *\n * @return  {Boolean}            Return true to prevent additional processing of this token\n */\nfunction processSecurityToken(token) {\n  if (token.name.match(/^[NUI]$/)) {\n    token.type = \"security\";\n\n    switch (token.name) {\n      case \"N\":\n        token.value = \"none\";\n        break;\n\n      case \"U\":\n        token.value = \"strong\";\n        break;\n\n      case \"I\":\n        token.value = \"weak\";\n        break;\n\n      default:\n    }\n\n    return true;\n  }\n\n  return false;\n},\n/**\n * Normalizes a version field, if it exists.\n *\n * @private\n * @method  processVersionField\n *\n * @param   {Object} token            A baskerville token\n * @param   {String} [token.version]  A version field\n */\nfunction processVersionField(token) {\n  if (token.version) {\n    token.version = token.version.replace(/_/g, \".\");\n  }\n},\n/**\n * Process architecture tokens (e.g. 64 bit arch). These initially get misinterpreted as having\n * a version, but that's not true, so, we have to do a bit of reconstructive surgery.\n *\n * @private\n * @method  processArchToken\n *\n * @param   {Object} token       A baskerville token\n *\n * @return  {Boolean}            Return true to prevent additional processing of this token\n */\nfunction processArchToken(token) {\n  if (token.version === \"64\" && [\"Win\", \"x\"].includes(token.name)) {\n    token.name = \"\".concat(token.name).concat(token.version);\n    delete token.version;\n    token.type = \"arch\";\n    return true;\n  }\n\n  return false;\n},\n/**\n * Identifies browsers.\n *\n * @private\n * @method  identifyBrowserTokens\n *\n * @param   {Object} token       A baskerville token\n * @param   {String} token.name  The name of the browser\n */\nfunction identifyBrowserTokens(token) {\n  if (BROWSERS.test(token.name) || token.like && BROWSERS.test(token.like)) {\n    token.type = \"browser\";\n  }\n},\n/**\n * Identifies browsers.\n *\n * @private\n * @method  identifyOSTokens\n *\n * @param   {Object} token       A baskerville token\n * @param   {String} token.name  The name of the operating system\n */\nfunction identifyOSTokens(token) {\n  if (OPERATING_SYSTEMS.test(token.name) || token.like && OPERATING_SYSTEMS.test(token.like)) {\n    token.type = \"os\";\n  }\n}];\n/**\n * Parses an user agent string and returns an array of tokens, sorted by name.\n *\n * @public as \"tokenize\"\n * @method tokenizeUserAgent\n *\n * @param  {String} userAgent  An user agent string\n *\n * @return {Object[]}          A sorted array of tokens\n *\n * @example:\n *   baskerville.tokenize(\"Mozilla/5.0 (compatible; Konqueror/4.4; Linux 2.6.32-22-generic; X11; en_US) KHTML/4.4.3 (like Gecko) Kubuntu\");\n */\n\nfunction tokenizeUserAgent(userAgent) {\n  const tokens = [];\n\n  const compact = obj => Object.keys(obj).forEach(key => obj[key] === undefined && delete obj[key]);\n\n  userAgent.replace(IN_PARENS_EXTRACTOR, (all, inParens) => {\n    for (const tmp of inParens.split(IN_PARENS_SPLITTER)) {\n      const entry = {};\n      [, entry.name, entry.version, entry.like] = tmp.match(IN_PARENS_MATCHER);\n      tokens.push(entry);\n    }\n\n    return \"\";\n  }).replace(OUT_PARENS_MATCHER, (all, name, version, like) => {\n    tokens.push({\n      name,\n      version,\n      like\n    });\n  });\n  tokens.sort((a, b) => {\n    if (a.name.toLowerCase() < b.name.toLowerCase()) {\n      return -1;\n    }\n\n    if (a.name.toLowerCase() > b.name.toLowerCase()) {\n      return 1;\n    }\n\n    if (a.version.toLowerCase() < b.version.toLowerCase()) {\n      return -1;\n    }\n\n    if (a.version.toLowerCase() > b.version.toLowerCase()) {\n      return 1;\n    }\n\n    return 0;\n  });\n  tokens.forEach(compact);\n  return tokens;\n}\n/**\n * Invokes each step in a pipeline of processors until it either reaches the\n * end, or one of them returns true.\n *\n * @private\n * @method  processToken\n *\n * @param   {Object} token  A token\n *\n * @return  {Object}        A processed token\n */\n\n\nfunction processToken(token) {\n  let final = false;\n\n  for (const processor of processors) {\n    if (final) {\n      break;\n    }\n\n    final = processor(token);\n  }\n\n  return token;\n}\n/**\n * Processes a token (or array of tokens), normalizing fields, identifying,\n * and decorating with additional fields. Processing is done by passing a copy\n * of each token thru a pipeline of processors, each of which is allowed to\n * modify the copy. If a processor returns true, processing for that token\n * will end.\n *\n * @public as \"process\"\n * @method processTokens\n *\n * @param  {Object|Object[]} tokens  A token or an array of tokens\n *\n * @return {Object|Object[]}         A processed token or array of processed tokens\n *\n * @example:\n *   baskerville.process(baskerville.tokenize(\"Mozilla/5.0 (compatible; Konqueror/4.4; Linux 2.6.32-22-generic; X11; en_US) KHTML/4.4.3 (like Gecko) Kubuntu\"));\n */\n\n\nfunction processTokens(tokens) {\n  if (typeof tokens === \"string\") {\n    return tokenizeUserAgent(tokens).map(token => processToken(Object.assign({}, token)));\n  }\n\n  if (tokens instanceof Array) {\n    return tokens.map(token => processToken(Object.assign({}, token)));\n  }\n\n  return processToken(Object.assign({}, tokens));\n}\n/**\n * Registers a processor. Each processor, in turn, is given a token, and is\n * permitted to modify that token. If the processor returns true, no further\n * processing will be performed on that token. In this way, a processor can\n * either behave as part of pipeline, identifying/normalizing what it can, or\n * it can take over and produce a final answer.\n *\n * @public\n * @method registerProcessor\n *\n * @param  {Function} processor  A processor\n *\n * @example:\n *   baskerville.registerProcessor(function identifyMobileDevices (token) {\n *     if (token.type === 'browser') {\n *       token.mobile = SOME_REGEX_OF_MOBILE_BROWSERS.test(token.name);\n *     } else if (token.type === 'os') {\n *       token.mobile = SOME_REGEX_OF_MOBILE_OPERATING_SYSTEMS.test(token.name);\n *     }\n *   });\n *\n * @example:\n *   var carmen = require('carmen'); // https://github.com/kmdavis/carmen\n *   baskerville.registerProcessor(function identifyLocale (token) {\n *     var locale = carmen.parse(token.name);\n *     if (locale) {\n *       token.type = 'locale';\n *       token.details = locale;\n *       return true; // We assume full ownership and responsibility for this token.\n *     }\n *     return false; // Let the other children play\n *   });\n */\n\n\nfunction registerProcessor(processor) {\n  processors.push(processor);\n}\n\nconst Baskerville = {\n  process: processTokens,\n  registerProcessor,\n  tokenize: tokenizeUserAgent\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Baskerville);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9CYXNrZXJ2aWxsZS8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbIklOX1BBUkVOU19FWFRSQUNUT1IiLCJSZWdFeHAiLCJJTl9QQVJFTlNfU1BMSVRURVIiLCJJTl9QQVJFTlNfTUFUQ0hFUiIsIk9VVF9QQVJFTlNfTUFUQ0hFUiIsIkJST1dTRVJTIiwiT1BFUkFUSU5HX1NZU1RFTVMiLCJwcm9jZXNzb3JzIiwicHJvY2Vzc1NlY3VyaXR5VG9rZW4iLCJ0b2tlbiIsIm5hbWUiLCJtYXRjaCIsInR5cGUiLCJ2YWx1ZSIsInByb2Nlc3NWZXJzaW9uRmllbGQiLCJ2ZXJzaW9uIiwicmVwbGFjZSIsInByb2Nlc3NBcmNoVG9rZW4iLCJpbmNsdWRlcyIsImlkZW50aWZ5QnJvd3NlclRva2VucyIsInRlc3QiLCJsaWtlIiwiaWRlbnRpZnlPU1Rva2VucyIsInRva2VuaXplVXNlckFnZW50IiwidXNlckFnZW50IiwidG9rZW5zIiwiY29tcGFjdCIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidW5kZWZpbmVkIiwiYWxsIiwiaW5QYXJlbnMiLCJ0bXAiLCJzcGxpdCIsImVudHJ5IiwicHVzaCIsInNvcnQiLCJhIiwiYiIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1Rva2VuIiwiZmluYWwiLCJwcm9jZXNzb3IiLCJwcm9jZXNzVG9rZW5zIiwibWFwIiwiYXNzaWduIiwiQXJyYXkiLCJyZWdpc3RlclByb2Nlc3NvciIsIkJhc2tlcnZpbGxlIiwicHJvY2VzcyIsInRva2VuaXplIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUEsTUFBTUEsbUJBQW1CLEdBQUcsSUFBSUMsTUFBSixDQUN4QixNQUFNO0FBQU4sRUFDTSxVQUROLENBQ2lCO0FBRGpCLEVBRU0sT0FGTixDQUVjO0FBRmQsRUFHRSxLQUpzQixFQUlmO0FBQ1QsR0FMd0IsQ0FBNUI7QUFPQSxNQUFNQyxrQkFBa0IsR0FBRyxPQUEz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QWQsRUFBa0J2QyxLQUFsQixDQUFELENBQW5ELENBQVA7QUFDSDs7QUFDRCxNQUFJZ0IsTUFBTSxZQUFZd0IsS0FBdEIsRUFBNkI7QUFDekIsV0FBT3hCLE1BQU0sQ0FBQ3NCLEdBQVAsQ0FBV3RDLEtBQUssSUFBSWtDLFlBQVksQ0FBQ2YsTUFBTSxDQUFDb0IsTUFBUCxDQUFjLEVBQWQsRUFBa0J2QyxLQUFsQixDQUFELENBQWhDLENBQVA7QUFDSDs7QUFDRCxTQUFPa0MsWUFBWSxDQUFDZixNQUFNLENBQUNvQixNQUFQLENBQWMsRUFBZCxFQUFrQnZCLE1BQWxCLENBQUQsQ0FBbkI7QUFDSDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQSxTQUFTeUIsaUJBQVQsQ0FBNEJMLFNBQTVCLEVBQXVDO0FBQ25DdEMsWUFBVSxDQUFDK0IsSUFBWCxDQUFnQk8sU0FBaEI7QUFDSDs7QUFFRCxNQUFNTSxXQUFXLEdBQUc7QUFDaEJDLFNBQU8sRUFBRU4sYUFETztBQUVoQkksbUJBRmdCO0FBR2hCRyxVQUFRLEVBQUU5QjtBQUhNLENBQXBCO0FBTWU0QiwwRUFBZiIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbmNvbnN0IElOX1BBUkVOU19FWFRSQUNUT1IgPSBuZXcgUmVnRXhwKFxuICAgIFwiXFxcXChcIiAvLyBiZWdpbiBwYXJlbnNcbiAgICAgICAgKyBcIig/IWxpa2UpXCIgLy8gaWdub3JlIGlmIGl0IHN0YXJ0cyB3aXRoIFwibGlrZVwiLCBlLmcuIEtIVE1MLzQuNC4zIChsaWtlIEdlY2tvKVxuICAgICAgICArIFwiKC4qPylcIiAvLyBleHRyYWN0IHRoaXMgcGFydFxuICAgICsgXCJcXFxcKVwiLCAvLyBlbmQgcGFyZW5zXG4gICAgXCJnXCIsXG4pO1xuY29uc3QgSU5fUEFSRU5TX1NQTElUVEVSID0gLztcXHMqL2c7XG5jb25zdCBJTl9QQVJFTlNfTUFUQ0hFUiA9IG5ldyBSZWdFeHAoXG4gICAgXCIoLis/KVwiIC8vIGxhemlseSBtYXRjaCBhbnl0aGluZywgYW5kIHNhdmUgaXQgLS0gdGhpcyBpcyB0aGUgXCJuYW1lXCIgZmllbGRcbiAgICArIFwiWy8uIF0/XCJcbiAgICArIFwiKFwiIC8vIHNhdmUgdGhlIHZlcnNpb25cbiAgICAgICAgLy8gdmVyc2lvbnMgY2FuIG9jY2FzaW9uYWxseSBzdGFydCB3aXRoIHNvbWUgdGV4dCxcbiAgICAgICAgLy8gZS5nLiBBRFItMTExMTEwMTE1NywgYXMgbG9uZyBhcyB0aGF0IHRleHQgaXMgc2VwYXJhdGVkIGZyb20gdGhlIHJlc3QgYnkgYSBoeXBoZW5cbiAgICAgICAgKyBcIig/OlxcXFx3Ky0pP1wiXG4gICAgICAgICsgXCJcXFxcZCtcIiAvLyByZXF1aXJlZCB0byBoYXZlIGF0IGxlYXN0IDEgbnVtYmVyXG4gICAgICAgIC8vIGFuZCBhIG51bWJlciBvZiBhbHBoYW51bWVyaWMgZmllbGRzIHNlcGFyYXRlZCBieSBhIGRvdCwgdW5kZXJzY29yZSBvciBoeXBoZW5cbiAgICAgICAgKyBcIig/OlsuXy1dP1xcXFx3KSpcIlxuICAgICsgXCIpP1wiIC8vIHllYWgsIHZlcnNpb24gaXNuJ3QgYWN0dWFsbHkgcmVxdWlyZWQuXG4gICAgLy8gc29tZSB0b2tlbnMgaGF2ZSBhIFwibGlrZVwiIGNvbW1lbnQsXG4gICAgLy8gZS5nLiBLSFRNTCwgbGlrZSBHZWNrbyBvciBDUFUgaVBob25lIE9TIDJfMF8xIGxpa2UgTWFjIE9TIFhcbiAgICArIFwiKD86LD8gbGlrZSAoLio/KVxcXFxzKik/JFwiLFxuKTtcbmNvbnN0IE9VVF9QQVJFTlNfTUFUQ0hFUiA9IG5ldyBSZWdFeHAoXG4gICAgXCIoW1xcXFx3LV0rKVwiIC8vIGhlcmUncyBvdXIgbmFtZSBmaWVsZC4gdW5saWtlIGluIHBhcmVucywgc3BhY2VzIGFyZSBOT1QgYWxsb3dlZFxuICAgICsgXCIoPzpcIlxuICAgICAgICArIFwiL1wiIC8vIG5hbWUgaXMgc2VwYXJhdGVkIGZyb20gdGhlIHZlcnNpb24gYnkgYSAvXG4gICAgICAgICsgXCIoXFxcXFMrKVwiIC8vIG91ciB2ZXJzaW9uIGZpZWxkXG4gICAgKyBcIik/XCJcbiAgICArIFwiKD86XFxcXHMrXFxcXChsaWtlXFxcXHMrKC4qPylcXFxcKSk/XCIsIC8vIGFuZCB0aGUgb3B0aW9uYWwgXCJsaWtlXCIgY29tbWVudFxuICAgIFwiZ1wiLFxuKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmNvbnN0IEJST1dTRVJTID0gL15hcHBsZXdlYmtpdHxjYW1pbm98Y2hyb21lfGNocm9tZWZyYW1lfGVkZ2V8ZmlyZWZveHxmbHVpZHxnZWNrb3woPzptcyk/aWUoPzogbW9iaWxlKT98a2h0bWx8a29ucXVlcm9yfG1vemlsbGF8b3BlcmEoPzogbW9iaXwgbWluaSk/fHByZXN0b3xzYWZhcml8c2Ftc3VuZyBpbnRlcm5ldHx0cmlkZW50fCg/OmFuZHJvaWR8YmFpZHV8YmxhY2tiZXJyeXxxcXx1YykgYnJvd3NlciQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5jb25zdCBPUEVSQVRJTkdfU1lTVEVNUyA9IC9eYW5kcm9pZHxiZW9zfGJsYWNrYmVycnl8Y3JpP29zfGt1YnVudHV8KD86ZnJlZWJzZHxsaW51eHxvcGVuYnNkKSg/OiBcXHcqKT98bWFjaW50b3NofG1hY19wb3dlcnBjfG1hY29zfCg/OmludGVsfHBwYyk/ID9tYWMgb3MgeHxzdW5vc3xzeW1ib3N8dWJ1bnR1fHdpbig/OmRvd3MgKT8oPzo5NXw5OHxudHxjZSk/JC9pO1xuXG5jb25zdCBwcm9jZXNzb3JzID0gW1xuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgdGhlIHNlY3VyaXR5IHRva2VuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kICBwcm9jZXNzU2VjdXJpdHlUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtICAge09iamVjdH0gdG9rZW4gICAgICAgQSBiYXNrZXJ2aWxsZSB0b2tlblxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9IHRva2VuLm5hbWUgIE9uZSBvZiB0aGUgbGV0dGVycyBOLCBVLCBvciBJXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB7Qm9vbGVhbn0gICAgICAgICAgICBSZXR1cm4gdHJ1ZSB0byBwcmV2ZW50IGFkZGl0aW9uYWwgcHJvY2Vzc2luZyBvZiB0aGlzIHRva2VuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NlY3VyaXR5VG9rZW4gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi5uYW1lLm1hdGNoKC9eW05VSV0kLykpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcInNlY3VyaXR5XCI7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIk5cIjogdG9rZW4udmFsdWUgPSBcIm5vbmVcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVVwiOiB0b2tlbi52YWx1ZSA9IFwic3Ryb25nXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIklcIjogdG9rZW4udmFsdWUgPSBcIndlYWtcIjsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB2ZXJzaW9uIGZpZWxkLCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgIHByb2Nlc3NWZXJzaW9uRmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IHRva2VuICAgICAgICAgICAgQSBiYXNrZXJ2aWxsZSB0b2tlblxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9IFt0b2tlbi52ZXJzaW9uXSAgQSB2ZXJzaW9uIGZpZWxkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1ZlcnNpb25GaWVsZCAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHRva2VuLnZlcnNpb24gPSB0b2tlbi52ZXJzaW9uLnJlcGxhY2UoL18vZywgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYXJjaGl0ZWN0dXJlIHRva2VucyAoZS5nLiA2NCBiaXQgYXJjaCkuIFRoZXNlIGluaXRpYWxseSBnZXQgbWlzaW50ZXJwcmV0ZWQgYXMgaGF2aW5nXG4gICAgICogYSB2ZXJzaW9uLCBidXQgdGhhdCdzIG5vdCB0cnVlLCBzbywgd2UgaGF2ZSB0byBkbyBhIGJpdCBvZiByZWNvbnN0cnVjdGl2ZSBzdXJnZXJ5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kICBwcm9jZXNzQXJjaFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSB0b2tlbiAgICAgICBBIGJhc2tlcnZpbGxlIHRva2VuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB7Qm9vbGVhbn0gICAgICAgICAgICBSZXR1cm4gdHJ1ZSB0byBwcmV2ZW50IGFkZGl0aW9uYWwgcHJvY2Vzc2luZyBvZiB0aGlzIHRva2VuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FyY2hUb2tlbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnZlcnNpb24gPT09IFwiNjRcIiAmJiBbXCJXaW5cIiwgXCJ4XCJdLmluY2x1ZGVzKHRva2VuLm5hbWUpKSB7XG4gICAgICAgICAgICB0b2tlbi5uYW1lID0gYCR7dG9rZW4ubmFtZX0ke3Rva2VuLnZlcnNpb259YDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi52ZXJzaW9uO1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiYXJjaFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kICBpZGVudGlmeUJyb3dzZXJUb2tlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IHRva2VuICAgICAgIEEgYmFza2VydmlsbGUgdG9rZW5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSB0b2tlbi5uYW1lICBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aWZ5QnJvd3NlclRva2VucyAodG9rZW4pIHtcbiAgICAgICAgaWYgKEJST1dTRVJTLnRlc3QodG9rZW4ubmFtZSlcbiAgICAgICAgICAgIHx8ICh0b2tlbi5saWtlICYmIEJST1dTRVJTLnRlc3QodG9rZW4ubGlrZSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiYnJvd3NlclwiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgIGlkZW50aWZ5T1NUb2tlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IHRva2VuICAgICAgIEEgYmFza2VydmlsbGUgdG9rZW5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSB0b2tlbi5uYW1lICBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW5nIHN5c3RlbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aWZ5T1NUb2tlbnMgKHRva2VuKSB7XG4gICAgICAgIGlmIChPUEVSQVRJTkdfU1lTVEVNUy50ZXN0KHRva2VuLm5hbWUpXG4gICAgICAgICAgICB8fCAodG9rZW4ubGlrZSAmJiBPUEVSQVRJTkdfU1lTVEVNUy50ZXN0KHRva2VuLmxpa2UpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIm9zXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gdXNlciBhZ2VudCBzdHJpbmcgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdG9rZW5zLCBzb3J0ZWQgYnkgbmFtZS5cbiAqXG4gKiBAcHVibGljIGFzIFwidG9rZW5pemVcIlxuICogQG1ldGhvZCB0b2tlbml6ZVVzZXJBZ2VudFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXNlckFnZW50ICBBbiB1c2VyIGFnZW50IHN0cmluZ1xuICpcbiAqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgICBBIHNvcnRlZCBhcnJheSBvZiB0b2tlbnNcbiAqXG4gKiBAZXhhbXBsZTpcbiAqICAgYmFza2VydmlsbGUudG9rZW5pemUoXCJNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgS29ucXVlcm9yLzQuNDsgTGludXggMi42LjMyLTIyLWdlbmVyaWM7IFgxMTsgZW5fVVMpIEtIVE1MLzQuNC4zIChsaWtlIEdlY2tvKSBLdWJ1bnR1XCIpO1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZVVzZXJBZ2VudCAodXNlckFnZW50KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG5cbiAgICBjb25zdCBjb21wYWN0ID0gb2JqID0+IChcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkICYmIGRlbGV0ZSBvYmpba2V5XSlcbiAgICApO1xuXG4gICAgdXNlckFnZW50XG4gICAgICAgIC5yZXBsYWNlKElOX1BBUkVOU19FWFRSQUNUT1IsIChhbGwsIGluUGFyZW5zKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRtcCBvZiBpblBhcmVucy5zcGxpdChJTl9QQVJFTlNfU1BMSVRURVIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7fTtcbiAgICAgICAgICAgICAgICBbLCBlbnRyeS5uYW1lLCBlbnRyeS52ZXJzaW9uLCBlbnRyeS5saWtlXSA9IHRtcC5tYXRjaChJTl9QQVJFTlNfTUFUQ0hFUik7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoT1VUX1BBUkVOU19NQVRDSEVSLCAoYWxsLCBuYW1lLCB2ZXJzaW9uLCBsaWtlKSA9PiB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IG5hbWUsIHZlcnNpb24sIGxpa2UgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgdG9rZW5zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEubmFtZS50b0xvd2VyQ2FzZSgpIDwgYi5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5uYW1lLnRvTG93ZXJDYXNlKCkgPiBiLm5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudmVyc2lvbi50b0xvd2VyQ2FzZSgpIDwgYi52ZXJzaW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS52ZXJzaW9uLnRvTG93ZXJDYXNlKCkgPiBiLnZlcnNpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICB0b2tlbnMuZm9yRWFjaChjb21wYWN0KTtcbiAgICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIEludm9rZXMgZWFjaCBzdGVwIGluIGEgcGlwZWxpbmUgb2YgcHJvY2Vzc29ycyB1bnRpbCBpdCBlaXRoZXIgcmVhY2hlcyB0aGVcbiAqIGVuZCwgb3Igb25lIG9mIHRoZW0gcmV0dXJucyB0cnVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kICBwcm9jZXNzVG9rZW5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0fSB0b2tlbiAgQSB0b2tlblxuICpcbiAqIEByZXR1cm4gIHtPYmplY3R9ICAgICAgICBBIHByb2Nlc3NlZCB0b2tlblxuICovXG5mdW5jdGlvbiBwcm9jZXNzVG9rZW4gKHRva2VuKSB7XG4gICAgbGV0IGZpbmFsID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgcHJvY2Vzc29ycykge1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsID0gcHJvY2Vzc29yKHRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGEgdG9rZW4gKG9yIGFycmF5IG9mIHRva2VucyksIG5vcm1hbGl6aW5nIGZpZWxkcywgaWRlbnRpZnlpbmcsXG4gKiBhbmQgZGVjb3JhdGluZyB3aXRoIGFkZGl0aW9uYWwgZmllbGRzLiBQcm9jZXNzaW5nIGlzIGRvbmUgYnkgcGFzc2luZyBhIGNvcHlcbiAqIG9mIGVhY2ggdG9rZW4gdGhydSBhIHBpcGVsaW5lIG9mIHByb2Nlc3NvcnMsIGVhY2ggb2Ygd2hpY2ggaXMgYWxsb3dlZCB0b1xuICogbW9kaWZ5IHRoZSBjb3B5LiBJZiBhIHByb2Nlc3NvciByZXR1cm5zIHRydWUsIHByb2Nlc3NpbmcgZm9yIHRoYXQgdG9rZW5cbiAqIHdpbGwgZW5kLlxuICpcbiAqIEBwdWJsaWMgYXMgXCJwcm9jZXNzXCJcbiAqIEBtZXRob2QgcHJvY2Vzc1Rva2Vuc1xuICpcbiAqIEBwYXJhbSAge09iamVjdHxPYmplY3RbXX0gdG9rZW5zICBBIHRva2VuIG9yIGFuIGFycmF5IG9mIHRva2Vuc1xuICpcbiAqIEByZXR1cm4ge09iamVjdHxPYmplY3RbXX0gICAgICAgICBBIHByb2Nlc3NlZCB0b2tlbiBvciBhcnJheSBvZiBwcm9jZXNzZWQgdG9rZW5zXG4gKlxuICogQGV4YW1wbGU6XG4gKiAgIGJhc2tlcnZpbGxlLnByb2Nlc3MoYmFza2VydmlsbGUudG9rZW5pemUoXCJNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgS29ucXVlcm9yLzQuNDsgTGludXggMi42LjMyLTIyLWdlbmVyaWM7IFgxMTsgZW5fVVMpIEtIVE1MLzQuNC4zIChsaWtlIEdlY2tvKSBLdWJ1bnR1XCIpKTtcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1Rva2VucyAodG9rZW5zKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuaXplVXNlckFnZW50KHRva2VucykubWFwKHRva2VuID0+IHByb2Nlc3NUb2tlbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbikpKTtcbiAgICB9XG4gICAgaWYgKHRva2VucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHByb2Nlc3NUb2tlbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NUb2tlbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbnMpKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBwcm9jZXNzb3IuIEVhY2ggcHJvY2Vzc29yLCBpbiB0dXJuLCBpcyBnaXZlbiBhIHRva2VuLCBhbmQgaXNcbiAqIHBlcm1pdHRlZCB0byBtb2RpZnkgdGhhdCB0b2tlbi4gSWYgdGhlIHByb2Nlc3NvciByZXR1cm5zIHRydWUsIG5vIGZ1cnRoZXJcbiAqIHByb2Nlc3Npbmcgd2lsbCBiZSBwZXJmb3JtZWQgb24gdGhhdCB0b2tlbi4gSW4gdGhpcyB3YXksIGEgcHJvY2Vzc29yIGNhblxuICogZWl0aGVyIGJlaGF2ZSBhcyBwYXJ0IG9mIHBpcGVsaW5lLCBpZGVudGlmeWluZy9ub3JtYWxpemluZyB3aGF0IGl0IGNhbiwgb3JcbiAqIGl0IGNhbiB0YWtlIG92ZXIgYW5kIHByb2R1Y2UgYSBmaW5hbCBhbnN3ZXIuXG4gKlxuICogQHB1YmxpY1xuICogQG1ldGhvZCByZWdpc3RlclByb2Nlc3NvclxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwcm9jZXNzb3IgIEEgcHJvY2Vzc29yXG4gKlxuICogQGV4YW1wbGU6XG4gKiAgIGJhc2tlcnZpbGxlLnJlZ2lzdGVyUHJvY2Vzc29yKGZ1bmN0aW9uIGlkZW50aWZ5TW9iaWxlRGV2aWNlcyAodG9rZW4pIHtcbiAqICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jyb3dzZXInKSB7XG4gKiAgICAgICB0b2tlbi5tb2JpbGUgPSBTT01FX1JFR0VYX09GX01PQklMRV9CUk9XU0VSUy50ZXN0KHRva2VuLm5hbWUpO1xuICogICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ29zJykge1xuICogICAgICAgdG9rZW4ubW9iaWxlID0gU09NRV9SRUdFWF9PRl9NT0JJTEVfT1BFUkFUSU5HX1NZU1RFTVMudGVzdCh0b2tlbi5uYW1lKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlOlxuICogICB2YXIgY2FybWVuID0gcmVxdWlyZSgnY2FybWVuJyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rbWRhdmlzL2Nhcm1lblxuICogICBiYXNrZXJ2aWxsZS5yZWdpc3RlclByb2Nlc3NvcihmdW5jdGlvbiBpZGVudGlmeUxvY2FsZSAodG9rZW4pIHtcbiAqICAgICB2YXIgbG9jYWxlID0gY2FybWVuLnBhcnNlKHRva2VuLm5hbWUpO1xuICogICAgIGlmIChsb2NhbGUpIHtcbiAqICAgICAgIHRva2VuLnR5cGUgPSAnbG9jYWxlJztcbiAqICAgICAgIHRva2VuLmRldGFpbHMgPSBsb2NhbGU7XG4gKiAgICAgICByZXR1cm4gdHJ1ZTsgLy8gV2UgYXNzdW1lIGZ1bGwgb3duZXJzaGlwIGFuZCByZXNwb25zaWJpbGl0eSBmb3IgdGhpcyB0b2tlbi5cbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIGZhbHNlOyAvLyBMZXQgdGhlIG90aGVyIGNoaWxkcmVuIHBsYXlcbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUHJvY2Vzc29yIChwcm9jZXNzb3IpIHtcbiAgICBwcm9jZXNzb3JzLnB1c2gocHJvY2Vzc29yKTtcbn1cblxuY29uc3QgQmFza2VydmlsbGUgPSB7XG4gICAgcHJvY2VzczogcHJvY2Vzc1Rva2VucyxcbiAgICByZWdpc3RlclByb2Nlc3NvcixcbiAgICB0b2tlbml6ZTogdG9rZW5pemVVc2VyQWdlbnQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCYXNrZXJ2aWxsZTtcbmV4cG9ydCB7XG4gICAgcHJvY2Vzc1Rva2VucyBhcyBwcm9jZXNzLFxuICAgIHJlZ2lzdGVyUHJvY2Vzc29yLFxuICAgIHRva2VuaXplVXNlckFnZW50IGFzIHRva2VuaXplLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });
});